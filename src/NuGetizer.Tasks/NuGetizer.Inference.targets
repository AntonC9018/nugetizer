<!--
***********************************************************************************************
NuGetizer.Inference.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <UsingTask TaskName="NuGetizer.Tasks.InferImplicitPackageReference" AssemblyFile="NuGetizer.Tasks.dll" />

  <PropertyGroup>
    <!-- The Kind of primary output (build, symbols and doc) set if PackBuildOutput = true -->
    <BuildOutputKind Condition="'$(BuildOutputKind)' == ''">Lib</BuildOutputKind>

    <!-- Whether to include @(Content) items with CopyToOutputDirectory != '' in the package -->
    <PackContent Condition="'$(PackContent)' == ''">true</PackContent>
    <!-- Whether to include @(None) items with CopyToOutputDirectory != '' in the package -->
    <PackNone Condition="'$(PackNone)' == ''">false</PackNone>
    <!-- Whether to include @(BuiltProjectOutputGroupOutput), @(DocumentationProjectOutputGroupOutput) and @(SatelliteDllsProjectOutputGroupOutput) items in the package -->
    <PackBuildOutput Condition="'$(PackBuildOutput)' == '' and '$(IsPackagingProject)' != 'true'">true</PackBuildOutput>
    <!-- Whether to include @(DebugSymbolsProjectOutputGroupOutput) items in the package -->
    <PackSymbols Condition="'$(PackSymbols)' == '' and '$(PackBuildOutput)' == 'true'">true</PackSymbols>
    <!-- Whether to include framework references (%(ReferencePath.ResolvedFrom)' == '{TargetFrameworkDirectory}') in the package -->

    <!-- Only default to true if the project isn't a nuget packaging project itself and its primary output is lib. -->
    <PackFrameworkReferences Condition="'$(PackFrameworkReferences)' == '' and '$(IsPackagingProject)' != 'true' and '$(BuildOutputKind)' == 'Lib'">true</PackFrameworkReferences>

    <_OutputFullPath Condition="$([System.IO.Path]::IsPathRooted($(OutputPath)))">$(OutputPath)</_OutputFullPath>
    <_OutputFullPath Condition="'$(_OutputFullPath)' == ''">$(MSBuildProjectDirectory.TrimEnd('\'))\$(OutputPath)</_OutputFullPath>
  </PropertyGroup>

  <PropertyGroup>
    <GetPackageContentsDependsOn>
      $(GetPackageContentsDependsOn);
      _BuildOutputFrameworkSpecific;
      _SetDefaultPackageReferencePack;
      InferPackageContents
    </GetPackageContentsDependsOn>
  </PropertyGroup>

  <!-- Extend some built-in items with metadata we use in our inference targets -->
  <ItemDefinitionGroup>
    <PackageReference>
      <Pack />
    </PackageReference>
    <ReferencePath>
      <Facade>false</Facade>
      <FrameworkFile>false</FrameworkFile>
      <NuGetPackageId />
      <Pack />
    </ReferencePath>
    <_ReferenceRelatedPaths>
      <Facade>false</Facade>
      <FrameworkFile>false</FrameworkFile>
      <NuGetPackageId />
      <Pack />
    </_ReferenceRelatedPaths>
  </ItemDefinitionGroup>

  <Target Name="_BuildOutputFrameworkSpecific" Condition="'$(BuildOutputFrameworkSpecific)' == ''" Returns="$(BuildOutputFrameworkSpecific)">
    <!-- Determine whether primary output is framework specific  -->
    <ItemGroup>
      <_BuildOutputKindFrameworkSpecific Include="@(PackageItemKind->'%(FrameworkSpecific)')" Condition="'%(Identity)' == '$(BuildOutputKind)'" />
    </ItemGroup>
    <PropertyGroup>
      <BuildOutputFrameworkSpecific>@(_BuildOutputKindFrameworkSpecific)</BuildOutputFrameworkSpecific>
    </PropertyGroup>
  </Target>
  
  <Target Name="_SetDefaultPackageReferencePack" Condition="'$(BuildOutputKind)' == 'build'"
          BeforeTargets="InferPrimaryOutputDependencies;InferPackageContents">
    <ItemGroup>
      <PackageReference Update="@(PackageReference)"
                        Condition="$([MSBuild]::ValueOrDefault('%(Identity)', '').StartsWith('Microsoft.Build')) and '%(Pack)' != 'true'"
                        Pack="false" />
    </ItemGroup>
  </Target>

  <Target Name="InferPackageContents" DependsOnTargets="$(InferPackageContentsDependsOn)" Returns="@(PackageFile)">
    <!-- Ensure TargetPath -->
    <AssignTargetPath Files="@(Content)" RootFolder="$(MSBuildProjectDirectory)"
                      Condition="'%(Content.Pack)' == 'true' or 
                                 '%(Content.PackagePath)' != '' or
                                 '%(Content.Kind)' != '' or 
                                 ('$(PackContent)' == 'true' and '%(Content.Pack)' != 'false')">
      <Output TaskParameter="AssignedFiles" ItemName="_ContentToInfer" />
    </AssignTargetPath>

    <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)"
                      Condition="'%(None.Pack)' == 'true' or 
                                 '%(None.PackagePath)' != '' or
                                 '%(None.Kind)' != '' or 
                                 ('$(PackNone)' == 'true' and '%(None.Pack)' != 'false')">
      <Output TaskParameter="AssignedFiles" ItemName="_NoneToInfer" />
    </AssignTargetPath>

    <ItemGroup>
			<!-- Unfortunately, even with https://github.com/Microsoft/msbuild/pull/1115, when multi-targeting 
           .NETFramework, the desktop WinFX.targets are imported which don't have the fix, so we need to 
           do it "the old way" for this particular output group -->
			<_SatelliteDllsProjectOutputGroupOutput Include="@(SatelliteDllsProjectOutputGroupOutput)" FinalOutputPath="'%(FullPath)')" />
      
      <_InferredProjectOutput Include="@(BuiltProjectOutputGroupOutput -> '%(FinalOutputPath)');
                                     @(BuiltProjectOutputGroupKeyOutput -> '%(FinalOutputPath)');
                                     @(DocumentationProjectOutputGroupOutput -> '%(FinalOutputPath)');
                                     @(_SatelliteDllsProjectOutputGroupOutput -> '%(FinalOutputPath)')"
                            Condition="'$(PackBuildOutput)' == 'true'">
        <Kind>$(BuildOutputKind)</Kind>
        <FrameworkSpecific>$(BuildOutputFrameworkSpecific)</FrameworkSpecific>
      </_InferredProjectOutput>

      <_InferredProjectOutput Include="@(DebugSymbolsProjectOutputGroupOutput -> '%(FinalOutputPath)')"
                            Condition="'$(PackBuildOutput)' == 'true' and '$(PackSymbols)' != 'false'">
        <Kind>$(BuildOutputKind)</Kind>
        <FrameworkSpecific>$(BuildOutputFrameworkSpecific)</FrameworkSpecific>
      </_InferredProjectOutput>

      <_InferredPackageFile Include="@(_InferredProjectOutput -> Distinct())" />

      <!-- NOTE: Content is opt-out (must have Pack=false to exclude if PackContent=true) -->
      <!-- Stuff that is copied to output should be included from that output location -->
      <_InferredPackageFile Include="@(_ContentToInfer->'$(_OutputFullPath)\%(TargetPath)')"
							   Condition="'%(_ContentToInfer.CopyToOutputDirectory)' != '' and '%(_ContentToInfer.CopyToOutputDirectory)' != 'Never'">
        <Kind Condition="'%(_ContentToInfer.Kind)' == ''">$(BuildOutputKind)</Kind>
      </_InferredPackageFile>
      <!-- Otherwise, include from source location and default to content -->
      <_InferredPackageFile Include="@(_ContentToInfer->'%(FullPath)')"
							   Condition="'%(_ContentToInfer.CopyToOutputDirectory)' == '' or '%(_ContentToInfer.CopyToOutputDirectory)' == 'Never'">
        <Kind Condition="'%(_ContentToInfer.Kind)' == ''">Content</Kind>
      </_InferredPackageFile>

      <!-- NOTE: None is also opt-out (must have Pack=false to exclude if PackNone=true, but this property defaults to false) -->
      <!-- Likewise, include from target path if it's copied, from source path otherwise -->
      <_InferredPackageFile Include="@(_NoneToInfer->'$(_OutputFullPath)\%(TargetPath)')"
							   Condition="'%(_NoneToInfer.CopyToOutputDirectory)' != '' and '%(_NoneToInfer.CopyToOutputDirectory)' != 'Never'">
        <Kind Condition="'%(_NoneToInfer.Kind)' == ''">$(BuildOutputKind)</Kind>
      </_InferredPackageFile>
      <_InferredPackageFile Include="@(_NoneToInfer->'%(FullPath)')"
							   Condition="'%(_NoneToInfer.CopyToOutputDirectory)' == '' or '%(_NoneToInfer.CopyToOutputDirectory)' == 'Never'">
        <Kind Condition="'%(_NoneToInfer.Kind)' == ''">None</Kind>
      </_InferredPackageFile>
      
      <_InferredPackageFile Include="@(PackageReference)" 
                            Condition="'%(PackageReference.Identity)' != 'NuGetizer' and
                                       '%(PackageReference.Identity)' != 'NETStandard.Library' and 
                                       '%(PackageReference.PrivateAssets)' != 'all' and
                                       '%(PackageReference.Pack)' != 'false'">
        <Kind>Dependency</Kind>
      </_InferredPackageFile>

      <!-- We can't use %(FrameworkFile)==true because it's not defined for raw file references and 
			     it also includes mscorlib which we don't need
			     TBD: maybe include ResolvedFrom=ImplicitlyExpandDesignTimeFacades too? -->
      <_InferredPackageFile Include="@(ReferencePath->'%(OriginalItemSpec)')"
                            Condition="'$(PackFrameworkReferences)' == 'true' and 
                                       '%(ReferencePath.ResolvedFrom)' == '{TargetFrameworkDirectory}' and 
                                       '%(ReferencePath.Pack)' != 'false'">
        <Kind>FrameworkReference</Kind>
      </_InferredPackageFile>
    </ItemGroup>

    <ItemGroup>
      <!-- 
				PackageId metadata on all PackageFile items means we can tell appart which ones came from which dependencies 
				NOTE: if PackageId is empty, we won't generate a manifest and it means the files need to be packed with the
				current project.
			-->
      <PackageFile Include="@(_InferredPackageFile)">
        <Source>Implicit</Source>
        <PackageId Condition="'$(IsPackable)' == 'true'">$(PackageId)</PackageId>
        <Platform>$(Platform)</Platform>
        <TargetFrameworkMoniker Condition="'$(IsPackagingProject)' != 'true'">$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
      </PackageFile>
    </ItemGroup>
  </Target>

  <Target Name="_CollectPrimaryOutputDependencies" DependsOnTargets="BuildOnlySettings;ResolveReferences" Returns="@(ImplicitPackageReference)">
    <ItemGroup>
      <_PrimaryOutputRelatedFile Include="@(ReferencePath);@(_ReferenceRelatedPaths)"
                                 Condition="'%(NuGetPackageId)' != 'NETStandard.Library' and 
                                            '%(Facade)' != 'true' and 
                                            '%(FrameworkFile)' != 'true' and 
                                            '%(Pack)' != 'false'"/>
      <_PrivateAssetsPackageReference Include="@(PackageReference -> WithMetadataValue('PrivateAssets', 'all'))"
                                      Condition="'%(PackageReference.IsImplicitlyDefined)' != 'true' and '%(PackageReference.Pack)' != 'false'"/>
    </ItemGroup>
    <InferImplicitPackageReference Condition="'@(_PrivateAssetsPackageReference)' != '' and '@(PackageDependencies)' != ''" 
                                   PackageReferences="@(_PrivateAssetsPackageReference)" 
                                   PackageDependencies="@(PackageDependencies)">
      <Output TaskParameter="ImplicitPackageReferences" ItemName="ImplicitPackageReference" />
    </InferImplicitPackageReference>
  </Target>
  
  <Target Name="_ResolvePackageDependencies" Condition="'$(UsingMicrosoftNETSdk)' == 'true'" DependsOnTargets="RunResolvePackageDependencies" />

  <Target Name="InferPrimaryOutputDependencies"
          Inputs="@(_PrimaryOutputRelatedFile)"
          Outputs="%(_PrimaryOutputRelatedFile.NuGetPackageId)"
          Returns="@(_InferredPackageFile)"
          DependsOnTargets="_ResolvePackageDependencies;_CollectPrimaryOutputDependencies">
    
    <ItemGroup>
      <_NuGetPackageId Include="@(_PrimaryOutputRelatedFile -> '%(NuGetPackageId)')" Condition="'%(NuGetPackageId)' != 'NETStandard.Library'" />
    </ItemGroup>
    <PropertyGroup>
      <_NuGetPackageId>@(_NuGetPackageId -> Distinct())</_NuGetPackageId>
    </PropertyGroup>
    <ItemGroup>
      <_PrimaryPackageReference Include="@(PackageReference);@(ImplicitPackageReference)" Condition="'$(_NuGetPackageId)' != '' and '%(Identity)' == '$(_NuGetPackageId)'" />
    </ItemGroup>
    
    <PropertyGroup>
      <_PrivateAssets>@(_PrimaryPackageReference -> '%(PrivateAssets)')</_PrivateAssets>
      <_ShouldPack>@(_PrimaryPackageReference -> '%(Pack)')</_ShouldPack>
      <_ShouldIncludeAssetsRegex>$(_NuGetPackageId)\\.+\\$(_PrivateAssets)\\.*</_ShouldIncludeAssetsRegex>
    </PropertyGroup>

    <ItemGroup Condition="'$(_ShouldPack)' != 'false' and '$(_PrivateAssets)' == 'all'">
      <_InferredPackageFile Include="@(_PrimaryOutputRelatedFile)" Condition="'%(_PrimaryOutputRelatedFile.FrameworkFile)' != 'true'">
        <Kind>$(BuildOutputKind)</Kind>
        <FrameworkSpecific>$(BuildOutputFrameworkSpecific)</FrameworkSpecific>
      </_InferredPackageFile>
    </ItemGroup>

    <ItemGroup Condition="'$(_ShouldPack)' != 'false' and '$(_PrivateAssets)' != 'all' and '$(_PrivateAssets)' != 'none' and '$(_PrivateAssets)' != ''">
      <!-- In this case, we only add files that have a matching path to the private assets value. 
				 i.e. for Mono.Options, PrivateAssets=lib, we'll include the file if its full path contains 
				 'Mono.Options\*\lib\*', meaning the file is a lib. -->
      <_InferredPackageFile Include="@(_PrimaryOutputRelatedFile)" 
                            Condition="$([System.Text.RegularExpressions.Regex]::IsMatch('%(_PrimaryOutputRelatedFile.FullPath)', '$(_ShouldIncludeAssetsRegex)', 'RegexOptions.IgnoreCase')) == 'true'">
        <Kind>$(BuildOutputKind)</Kind>
        <FrameworkSpecific>$(BuildOutputFrameworkSpecific)</FrameworkSpecific>
      </_InferredPackageFile>
    </ItemGroup>
  </Target>

  <Target Name="_SetInferPackageContentsDependsOn" AfterTargets="_SetPropertiesFromCapabilities">
    <PropertyGroup>
      <!-- NOTE: this avoids taking dependencies on targets that are only available when the project supports the concept of references -->
      <_SupportsReferences Condition="
						$(_AllProjectCapabilities.Contains('AssemblyReferences')) or 
						$(_AllProjectCapabilities.Contains('COMReferences')) or
						$(_AllProjectCapabilities.Contains('ProjectReferences')) or 
						$(_AllProjectCapabilities.Contains('PackageReferences')) or 
						$(_AllProjectCapabilities.Contains('WinRTReferences')) or
						$(_AllProjectCapabilities.Contains('SDKReferences'))">true</_SupportsReferences>

      <InferPackageContentsDependsOn Condition="'$(_SupportsReferences)' == 'true'">
        ResolveReferences;
        InferPrimaryOutputDependencies
      </InferPackageContentsDependsOn>
      <InferPackageContentsDependsOn>
        $(InferPackageContentsDependsOn);
        GetPackageTargetPath
      </InferPackageContentsDependsOn>
      <InferPackageContentsDependsOn Condition="$(_AllProjectCapabilities.Contains('AllTargetOutputGroups'))">
        $(InferPackageContentsDependsOn);
        AllProjectOutputGroups
      </InferPackageContentsDependsOn>
    </PropertyGroup>
  </Target>

</Project>
