<!--
***********************************************************************************************
NuGetizer.Inference.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <UsingTask TaskName="NuGetizer.Tasks.InferImplicitPackageReference" AssemblyFile="NuGetizer.Tasks.dll" />

  <PropertyGroup>
    <!-- The Kind of primary output (build, symbols and doc) set if PackBuildOutput = true -->
    <BuildOutputKind Condition="'$(BuildOutputKind)' == ''">Lib</BuildOutputKind>

    <!-- Whether to include @(Compile) items in the package -->
    <PackCompile Condition="'$(PackCompile)' == ''">false</PackCompile>
    <!-- Whether to include @(Content) items with CopyToOutputDirectory != '' in the package -->
    <PackContent Condition="'$(PackContent)' == ''">true</PackContent>
    <!-- Whether to include @(None) items with CopyToOutputDirectory != '' in the package -->
    <PackNone Condition="'$(PackNone)' == ''">false</PackNone>
    <!-- Whether to include @(None) items with CopyToOutputDirectory != '' in the package -->
    <PackEmbeddedResource Condition="'$(PackEmbeddedResource)' == ''">false</PackEmbeddedResource>   
    <!-- Whether to include @(BuiltProjectOutputGroupOutput), @(DocumentationProjectOutputGroupOutput) and @(SatelliteDllsProjectOutputGroupOutput) items in the package -->
    <PackBuildOutput Condition="'$(PackBuildOutput)' == '' and '$(IsPackagingProject)' != 'true'">true</PackBuildOutput>
    <!-- Whether to include @(DebugSymbolsProjectOutputGroupOutput) items in the package -->
    <PackSymbols Condition="'$(PackSymbols)' == '' and '$(PackBuildOutput)' == 'true'">true</PackSymbols>
    <!-- Whether to include framework references (%(ReferencePath.ResolvedFrom)' == '{TargetFrameworkDirectory}') in the package -->

    <!-- Only default to true if the project isn't a nuget packaging project itself and its primary output is lib. -->
    <PackFrameworkReferences Condition="'$(PackFrameworkReferences)' == '' and '$(IsPackagingProject)' != 'true' and '$(BuildOutputKind)' == 'Lib'">true</PackFrameworkReferences>

    <_OutputFullPath Condition="$([System.IO.Path]::IsPathRooted($(OutputPath)))">$(OutputPath)</_OutputFullPath>
    <_OutputFullPath Condition="'$(_OutputFullPath)' == ''">$(MSBuildProjectDirectory.TrimEnd('\'))\$(OutputPath)</_OutputFullPath>
  </PropertyGroup>

  <ItemDefinitionGroup Label="Inference Defaults">
    <Compile>
      <!-- For Compile, the CodeLanguage should default to the project's default source extension -->
      <CodeLanguage>$(DefaultLanguageSourceExtension.TrimStart('.'))</CodeLanguage>
      <Pack Condition="'$(PackCompile)' == 'true'">true</Pack>
      <DefaultKind>content</DefaultKind>
    </Compile>
    <Content>
      <Pack Condition="'$(PackContent)' == true">true</Pack>
      <DefaultKind>content</DefaultKind>
    </Content>
    <EmbeddedResource>
      <Pack Condition="'$(PackEmbeddedResource)' == true">true</Pack>
      <DefaultKind>content</DefaultKind>
    </EmbeddedResource>
    <None>
      <Pack Condition="'$(PackNone)' == true">true</Pack>
      <DefaultKind>none</DefaultKind>
    </None>
    <InferenceCandidate>
      <DefaultKind />
      <Pack />
      <PackagePath />
      <Kind />
      <ShouldPack />
    </InferenceCandidate>
  </ItemDefinitionGroup>
  
  <!-- Extend some built-in items with metadata we use in our inference targets -->
  <ItemDefinitionGroup>
    <PackageReference>
      <Pack />
    </PackageReference>
    <ReferencePath>
      <Facade>false</Facade>
      <FrameworkFile>false</FrameworkFile>
      <NuGetPackageId />
      <Pack />
    </ReferencePath>
    <_ReferenceRelatedPaths>
      <Facade>false</Facade>
      <FrameworkFile>false</FrameworkFile>
      <NuGetPackageId />
      <Pack />
    </_ReferenceRelatedPaths>
  </ItemDefinitionGroup>

  <PropertyGroup>
    <GetPackageContentsDependsOn>
      $(GetPackageContentsDependsOn);
      _SetBuildOutputFrameworkSpecific;
      _SetDefaultPackageReferencePack;
      InferPackageContents
    </GetPackageContentsDependsOn>
  </PropertyGroup>

  <Target Name="_SetBuildOutputFrameworkSpecific" Condition="'$(BuildOutputFrameworkSpecific)' == ''" Returns="$(BuildOutputFrameworkSpecific)">
    <!-- Determine whether primary output is framework specific  -->
    <ItemGroup>
      <_BuildOutputKindFrameworkSpecific Include="@(PackageItemKind->'%(FrameworkSpecific)')" Condition="'%(Identity)' == '$(BuildOutputKind)'" />
    </ItemGroup>
    <PropertyGroup>
      <BuildOutputFrameworkSpecific>@(_BuildOutputKindFrameworkSpecific)</BuildOutputFrameworkSpecific>
    </PropertyGroup>
  </Target>
  
  <Target Name="_SetDefaultPackageReferencePack" Condition="'$(BuildOutputKind)' == 'build'"
          BeforeTargets="InferPrimaryOutputDependencies;InferPackageContents">
    <ItemGroup>
      <PackageReference Update="@(PackageReference)"
                        Condition="$([MSBuild]::ValueOrDefault('%(Identity)', '').StartsWith('Microsoft.Build')) and '%(Pack)' != 'true'"
                        Pack="false" />
    </ItemGroup>
  </Target>

  <ItemGroup>
    <PackInference Include="Compile;Content;EmbeddedResource;None" />
  </ItemGroup>
  
  <Target Name="InferPackageContents" DependsOnTargets="$(InferPackageContentsDependsOn)" Returns="@(PackageFile)">
    <ItemGroup>
      <InferenceCandidate Include="@(%(PackInference.Identity))" />
      <InferenceCandidate>
        <ShouldPack Condition="('%(Pack)' == 'true' or '%(PackagePath)' != '' or '%(Kind)' != '') and '%(Pack)' != 'false'">true</ShouldPack>
      </InferenceCandidate>
    </ItemGroup>

    <AssignTargetPath Files="@(InferenceCandidate)" RootFolder="$(MSBuildProjectDirectory)"
                      Condition="'%(ShouldPack)' == 'true'">
      <Output TaskParameter="AssignedFiles" ItemName="_InferenceCandidateWithTargetPath" />
    </AssignTargetPath>

    <ItemGroup Label="PackInference">
      <_InferenceCandidateWithTargetPath Condition="'%(Kind)' == ''">
        <!-- Items that are copied to the output directory adopt the kind of the build output -->
        <Kind Condition="'%(_InferenceCandidateWithTargetPath.CopyToOutputDirectory)' != '' or 
                         '%(_InferenceCandidateWithTargetPath.CopyToOutputDirectory)' != 'Never'">$(BuildOutputKind)</Kind>
        <!-- Otherwise they cake on whichever is the default for their item type, as defined by their PackInference item -->
        <Kind Condition="'%(_InferenceCandidateWithTargetPath.CopyToOutputDirectory)' == '' or 
                         '%(_InferenceCandidateWithTargetPath.CopyToOutputDirectory)' == 'Never'">%(_InferenceCandidateWithTargetPath.DefaultKind)</Kind>        
      </_InferenceCandidateWithTargetPath>
      
        <!-- Items that are copied to the output directory are included from the target path -->
      <_InferredPackageFile Include="@(_InferenceCandidateWithTargetPath -> '$(_OutputFullPath)\%(TargetPath)')"
                            Condition="'%(_InferenceCandidateWithTargetPath.CopyToOutputDirectory)' != '' and 
                                       '%(_InferenceCandidateWithTargetPath.CopyToOutputDirectory)' != 'Never'" />
      <!-- Otherwise, they are included from the source location -->
      <_InferredPackageFile Include="@(_InferenceCandidateWithTargetPath->'%(FullPath)')"
                            Condition="'%(_InferenceCandidateWithTargetPath.CopyToOutputDirectory)' == '' or 
                                       '%(_InferenceCandidateWithTargetPath.CopyToOutputDirectory)' == 'Never'" />
    </ItemGroup>

    <ItemGroup Label="BuildOutput Inference" Condition="'$(PackBuildOutput)' == 'true'">
			<!-- Unfortunately, even with https://github.com/Microsoft/msbuild/pull/1115, when multi-targeting 
           .NETFramework, the desktop WinFX.targets are imported which don't have the fix, so we need to 
           do it "the old way" for this particular output group -->
			<_SatelliteDllsProjectOutputGroupOutput Include="@(SatelliteDllsProjectOutputGroupOutput)" 
                                              FinalOutputPath="'%(FullPath)')" />
      
      <_InferredProjectOutput Include="@(BuiltProjectOutputGroupOutput -> '%(FinalOutputPath)');
                                     @(BuiltProjectOutputGroupKeyOutput -> '%(FinalOutputPath)');
                                     @(DocumentationProjectOutputGroupOutput -> '%(FinalOutputPath)');
                                     @(_SatelliteDllsProjectOutputGroupOutput -> '%(FinalOutputPath)')">
        <Kind>$(BuildOutputKind)</Kind>
        <FrameworkSpecific>$(BuildOutputFrameworkSpecific)</FrameworkSpecific>
      </_InferredProjectOutput>

      <_InferredProjectOutput Include="@(DebugSymbolsProjectOutputGroupOutput -> '%(FinalOutputPath)')"
                            Condition="'$(PackSymbols)' != 'false'">
        <Kind>$(BuildOutputKind)</Kind>
        <FrameworkSpecific>$(BuildOutputFrameworkSpecific)</FrameworkSpecific>
      </_InferredProjectOutput>

      <_InferredPackageFile Include="@(_InferredProjectOutput -> Distinct())" />
    </ItemGroup>

    <ItemGroup Label="References Inference">
      <_InferredPackageFile Include="@(PackageReference)"
                            Condition="'%(PackageReference.Identity)' != 'NuGetizer' and
                                       '%(PackageReference.Identity)' != 'NETStandard.Library' and 
                                       '%(PackageReference.PrivateAssets)' != 'all' and
                                       '%(PackageReference.Pack)' != 'false'">
        <Kind>Dependency</Kind>
      </_InferredPackageFile>

      <!-- We can't use %(FrameworkFile)==true because it's not defined for raw file references and 
			     it also includes mscorlib which we don't need
			     TBD: maybe include ResolvedFrom=ImplicitlyExpandDesignTimeFacades too? -->
      <_InferredPackageFile Include="@(ReferencePath->'%(OriginalItemSpec)')"
                            Condition="'$(PackFrameworkReferences)' == 'true' and 
                                       '%(ReferencePath.ResolvedFrom)' == '{TargetFrameworkDirectory}' and 
                                       '%(ReferencePath.Pack)' != 'false'">
        <Kind>FrameworkReference</Kind>
      </_InferredPackageFile>
    </ItemGroup>

    <ItemGroup>
      <!-- 
				PackageId metadata on all PackageFile items means we can tell appart which ones came from which dependencies 
				NOTE: if PackageId is empty, we won't generate a manifest and it means the files need to be packed with the
				current project.
			-->
      <PackageFile Include="@(_InferredPackageFile)">
        <Source>Implicit</Source>
        <PackageId Condition="'$(IsPackable)' == 'true'">$(PackageId)</PackageId>
        <Platform>$(Platform)</Platform>
        <TargetFrameworkMoniker Condition="'$(IsPackagingProject)' != 'true'">$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
      </PackageFile>
    </ItemGroup>
  </Target>

  <Target Name="_CollectPrimaryOutputDependencies" DependsOnTargets="BuildOnlySettings;ResolveReferences" Returns="@(ImplicitPackageReference)">
    <ItemGroup>
      <_PrimaryOutputRelatedFile Include="@(ReferencePath);@(_ReferenceRelatedPaths)"
                                 Condition="'%(NuGetPackageId)' != 'NETStandard.Library' and 
                                            '%(Facade)' != 'true' and 
                                            '%(FrameworkFile)' != 'true' and 
                                            '%(Pack)' != 'false'"/>
      <_PrivateAssetsPackageReference Include="@(PackageReference -> WithMetadataValue('PrivateAssets', 'all'))"
                                      Condition="'%(PackageReference.IsImplicitlyDefined)' != 'true' and '%(PackageReference.Pack)' != 'false'"/>
    </ItemGroup>
    <InferImplicitPackageReference Condition="'@(_PrivateAssetsPackageReference)' != '' and '@(PackageDependencies)' != ''" 
                                   PackageReferences="@(_PrivateAssetsPackageReference)" 
                                   PackageDependencies="@(PackageDependencies)">
      <Output TaskParameter="ImplicitPackageReferences" ItemName="ImplicitPackageReference" />
    </InferImplicitPackageReference>
  </Target>
  
  <Target Name="_ResolvePackageDependencies" Condition="'$(UsingMicrosoftNETSdk)' == 'true'" DependsOnTargets="RunResolvePackageDependencies" />

  <Target Name="InferPrimaryOutputDependencies"
          Inputs="@(_PrimaryOutputRelatedFile)"
          Outputs="%(_PrimaryOutputRelatedFile.NuGetPackageId)"
          Returns="@(_InferredPackageFile)"
          DependsOnTargets="_ResolvePackageDependencies;_CollectPrimaryOutputDependencies">
    
    <ItemGroup>
      <_NuGetPackageId Include="@(_PrimaryOutputRelatedFile -> '%(NuGetPackageId)')" Condition="'%(NuGetPackageId)' != 'NETStandard.Library'" />
    </ItemGroup>
    <PropertyGroup>
      <_NuGetPackageId>@(_NuGetPackageId -> Distinct())</_NuGetPackageId>
    </PropertyGroup>
    <ItemGroup>
      <_PrimaryPackageReference Include="@(PackageReference);@(ImplicitPackageReference)" Condition="'$(_NuGetPackageId)' != '' and '%(Identity)' == '$(_NuGetPackageId)'" />
    </ItemGroup>
    
    <PropertyGroup>
      <_PrivateAssets>@(_PrimaryPackageReference -> '%(PrivateAssets)')</_PrivateAssets>
      <_ShouldPack>@(_PrimaryPackageReference -> '%(Pack)')</_ShouldPack>
      <_ShouldIncludeAssetsRegex>$(_NuGetPackageId)\\.+\\$(_PrivateAssets)\\.*</_ShouldIncludeAssetsRegex>
    </PropertyGroup>

    <ItemGroup Condition="'$(_ShouldPack)' != 'false' and '$(_PrivateAssets)' == 'all'">
      <_InferredPackageFile Include="@(_PrimaryOutputRelatedFile)" Condition="'%(_PrimaryOutputRelatedFile.FrameworkFile)' != 'true'">
        <Kind>$(BuildOutputKind)</Kind>
        <FrameworkSpecific>$(BuildOutputFrameworkSpecific)</FrameworkSpecific>
      </_InferredPackageFile>
    </ItemGroup>

    <ItemGroup Condition="'$(_ShouldPack)' != 'false' and '$(_PrivateAssets)' != 'all' and '$(_PrivateAssets)' != 'none' and '$(_PrivateAssets)' != ''">
      <!-- In this case, we only add files that have a matching path to the private assets value. 
				 i.e. for Mono.Options, PrivateAssets=lib, we'll include the file if its full path contains 
				 'Mono.Options\*\lib\*', meaning the file is a lib. -->
      <_InferredPackageFile Include="@(_PrimaryOutputRelatedFile)" 
                            Condition="$([System.Text.RegularExpressions.Regex]::IsMatch('%(_PrimaryOutputRelatedFile.FullPath)', '$(_ShouldIncludeAssetsRegex)', 'RegexOptions.IgnoreCase')) == 'true'">
        <Kind>$(BuildOutputKind)</Kind>
        <FrameworkSpecific>$(BuildOutputFrameworkSpecific)</FrameworkSpecific>
      </_InferredPackageFile>
    </ItemGroup>
  </Target>

  <Target Name="_SetInferPackageContentsDependsOn" AfterTargets="_SetPropertiesFromCapabilities">
    <PropertyGroup>
      <!-- NOTE: this avoids taking dependencies on targets that are only available when the project supports the concept of references -->
      <_SupportsReferences Condition="
						$(_AllProjectCapabilities.Contains('AssemblyReferences')) or 
						$(_AllProjectCapabilities.Contains('COMReferences')) or
						$(_AllProjectCapabilities.Contains('ProjectReferences')) or 
						$(_AllProjectCapabilities.Contains('PackageReferences')) or 
						$(_AllProjectCapabilities.Contains('WinRTReferences')) or
						$(_AllProjectCapabilities.Contains('SDKReferences'))">true</_SupportsReferences>

      <InferPackageContentsDependsOn Condition="'$(_SupportsReferences)' == 'true'">
        ResolveReferences;
        InferPrimaryOutputDependencies
      </InferPackageContentsDependsOn>
      <InferPackageContentsDependsOn>
        $(InferPackageContentsDependsOn);
        GetPackageTargetPath
      </InferPackageContentsDependsOn>
      <InferPackageContentsDependsOn Condition="$(_AllProjectCapabilities.Contains('AllTargetOutputGroups'))">
        $(InferPackageContentsDependsOn);
        AllProjectOutputGroups
      </InferPackageContentsDependsOn>
    </PropertyGroup>
  </Target>

</Project>
